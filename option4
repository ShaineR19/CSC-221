def fte_per_faculty(data):
    """Prompts user for faculty name and then creates an excel sheet
    with FTE information for the courses for that faculty member

    Parameters
    ----------
    faculty_data: pd.DataFrame
        DataFrame to extract information from
    course_tier: pd.DataFrame
        DataFrame to extract information from
    """
    # Read FTE tier data
    course_tier = pd.read_excel('FTE_Tier.xlsx')
    unique_faculty = get_column_uniques(data,
                                                  "Sec Faculty Info")
    faculty = menu.fte_faculty_submenu(unique_faculty)
    if faculty:
        frame = get_faculty_frame(data, faculty)
        frame = frame[[
            "Sec Name", "X Sec Delivery Method", "Meeting Times",
            "Capacity", "FTE Count", "Total FTE"
        ]].copy()
        courses = get_column_uniques(frame, "Sec Name")
        course_codes = sorted(get_course_codes(courses))
        filename = faculty.split()[1] + faculty[
            0]  # lastname + first initial
        generate_and_save_fte_report(
            frame=frame,
            course_tier=course_tier,
            course_codes=course_codes,
            filename=filename,
            first_cell=faculty,
            apply_filter=True
        )
        
def get_faculty_frame(data, name):
    """Extracts rows associated with a faculty member or ones not
    assigned yet.

    Parameters
    ----------
    data: pd.DataFrame
        DataFrame to extract rows from
    name: str
        Faculty name to filter for. 'To be Announced' if looking for
        unassigned courses.

    Returns
    -------
    pd.DataFrame
        All rows associated to the given faculty member of no faculty
        member.
    """
    assert isinstance(data, pd.DataFrame)
    assert name is not None

    # Get faculty rows
    frame = data[data["Sec Faculty Info"] == name]

    return frame

def generate_and_save_fte_report(frame, course_tier, course_codes, filename, first_cell=None, apply_filter=True):
    """
    Applies enrollment %, generates FTE, and writes formatted report.
    """
    frame["Enrollment Per"] = calculate_enrollment_percentage(
        frame["FTE Count"], frame["Capacity"])
    if course_tier is not None:
        frame = generate_fte(frame, course_tier)

    create_fte_excel(
        data=frame,
        name=filename,
        course_codes=course_codes,
        first_cell=first_cell,
        apply_filter=apply_filter
    )


def create_fte_excel(data, name, course_codes, first_cell=None,
                     apply_filter=True):
    """Writes a formatted FTE excel file to the current directory

    Parameters
    ----------
    data: pd.DataFrame
        Division dataframe.
    name: str
        Name of the excel file.
    course_codes: list[str]
        List of unique course codes without section information.
    first_cell: str | None (default = None)
        If not None, the value will be written to the first cell
        of the sheet.
    apply_filter: bool
        If true, course frame will be filtered.
    """

    # Get the total FTE values
    course_totals, final_total = total_ftes(data)

    # Determine if faculty or div file to use as label for final total
    is_faculty_report = "Faculty Name" in data.columns
    total_label = "Faculty Total" if is_faculty_report else "Div Total"

    course_name = re.match(r"[A-Z]{3}-\d{3}[A-Z]?", name)
    if course_name is not None:
        filename = name.split("-")[0].lower() + name.split("-")[1]
    else:
        filename = name.lower()
    filename += "_FTE.xlsx"
    file_path = os.path.join(os.getcwd(), filename)

    current_row = 0
    start_column = 1 if first_cell is None else 2

    excel_options = {'nan_inf_to_errors': True}
    with xlsxwriter.Workbook(file_path, excel_options) as workbook:
        worksheet = workbook.add_worksheet()
        # Write the header row.
        if first_cell is not None:
            worksheet.write(current_row, 0, first_cell)
            worksheet.write(current_row, 1, "Course Code")
            worksheet.write_row(0, start_column, data.columns)
        else:
            worksheet.write(current_row, 0, "Course Code")
            worksheet.write_row(0, start_column, data.columns)

        current_row += 1
        # Write the course information.
        for course in course_codes:
            course_info = get_course_frame(data, course,
                                                     apply_filter)
            course_info = sort_dataframe(course_info,
                                                   ["Sec Name"])
            # Write course name to the cell in the column/row before the
            # course information.
            worksheet.write(current_row, start_column - 1, course)
            current_row += 1
            # Write the course information.
            for row in course_info.itertuples(index=False):
                worksheet.write_row(current_row, start_column, row)
                current_row += 1
            # Write total.
            worksheet.write(current_row, start_column - 1, "Total")
            fte_column_index = data.columns.get_loc(
                "Generated FTE"
            ) + start_column if "Generated FTE" in data.columns else start_column + 4
            worksheet.write(current_row, fte_column_index,
                            course_totals.get(course, 0))
            current_row += 1

        # Write div total for division, instructor
        if first_cell is not None:
            worksheet.write(current_row, 1, total_label)
            if "Generated FTE" in data.columns:
                fte_column_index = data.columns.get_loc(
                    "Generated FTE") + start_column
            else:
                fte_column_index = data.columns.get_loc(
                    "Generated FTE"
                ) + start_column if "Generated_FTE" in data.columns else start_column + 4
            worksheet.write(current_row, fte_column_index, final_total)
        # Try to fit the columns to the data.
        #worksheet.set_column(0, start_column + len(data.columns), 25)  # Set width for all columns
        for col_idx in range(start_column + len(data.columns) + 1):
            # Set specific widths for known columns
            if col_idx == 0 and first_cell is not None:  # First cell column
                worksheet.set_column(col_idx, col_idx, 15)
            elif col_idx == start_column - 1:  # Course Code column
                worksheet.set_column(col_idx, col_idx, 12)
            elif "Sec Name" in data.columns and col_idx == data.columns.get_loc("Sec Name") + start_column:
                worksheet.set_column(col_idx, col_idx, 10)  # Section name
            elif "Faculty Name" in data.columns and col_idx == data.columns.get_loc("Faculty Name") + start_column:
                worksheet.set_column(col_idx, col_idx, 20)  # Faculty name
            elif "Generated FTE" in data.columns and col_idx == data.columns.get_loc("Generated FTE") + start_column:
                worksheet.set_column(col_idx, col_idx, 12)  # FTE values
            elif "Enrollment Per" in data.columns and col_idx == data.columns.get_loc("Enrollment Per") + start_column:
                worksheet.set_column(col_idx, col_idx, 14)  # Enrollment percentage
            else:
                # Other columns get a reasonable default
                worksheet.set_column(col_idx, col_idx, 15)

    print(f"Created file: {file_path}")

def get_course_frame(data, name, apply_filter=True):
    """Extracts rows associated with a course code

    Parameters
    ----------
    data: pd.DataFrame
        DataFrame to extract rows from.
    name: str
        Course code to filter for.
    filter: bool (default = True)
        If true, face-to-face courses will be filtered

    Returns
    -------
    pd.DataFrame
        All rows associated to the Course Code without face-to-face
        classes with INET meeting times if filtered, else all rows.
    """

    assert isinstance(data, pd.DataFrame)
    assert name is not None

    # Filter for matching course code
    frame = data[data["Sec Name"].str.contains(name, case=False,
                                               na=False)].copy()

    if apply_filter:
        frame = remove_duplicate_sections(frame)
    else:
        frame = remove_duplicate_sections(frame)

    return frame

def remove_duplicate_sections(frame):
    """
    Removes duplicate course section rows based on 'Sec Name'.
    Keeps the first entry for each section (regardless of delivery method).

    Parameters
    ----------
    frame : pd.DataFrame
        DataFrame with potential duplicate course sections.

    Returns
    -------
    pd.DataFrame
        Cleaned DataFrame with only one row per section.
    """


    assert isinstance(frame, pd.DataFrame)
    frame = frame.sort_values(by=["Sec Name", "Meeting Times"], na_position='last')
    return frame.drop_duplicates(subset=["Sec Name"], keep="first")


def sort_dataframe(data, sort_by=["Sec Divisions", "Sec Name",
                                  "Sec Faculty Info"]):
    """Sorts a DataFrame by columns, in ascending order.

    Parameters
    ----------
    data: pd.DataFrame
        DataFrame to sort.
    sort_by: list[str]
        (default = ["Sec Divisions", "Sec Name", "Sec Faculty Info"])
        Column name(s) to sort by.

    Returns
    -------
    pd.DataFrame
        Sorted DataFrame
    """
    assert isinstance(data, pd.DataFrame)
    return data.sort_values(by=sort_by)

def total_ftes(data):
    """
    calculates to total FTE for each course and for a division
    :param data: ps.DataFrame
        A DataFrame that has individual secs generated FTE
    :return:
    course_fte: dictionary
        courses and their total generated FTE
    final_fte: Interger
        total generated FTE for entire dataframe
    """
    assert isinstance(data, pd.DataFrame)


def generate_fte(data, tier, support=1926):
    """
    calculates generated FTE for a set of data and returns new dataframe
    containing generated fte

    Parameters
    ----------
    data: pd.DataFrame
        DataFrame to calculate generated FTE for

    tier: pd.DataFrame
        DataFrame that holds the proposed funding lever for different
        tiers

    Returns
    -------
    pd.DataFrame
        generate_fte: a new DataFrame that has the generated FTE
    """
    assert isinstance(data, pd.DataFrame)
    assert isinstance(tier, pd.DataFrame)

    # Constant value used for calculating FTE
    try:
        # Ensure valid dataframes
        if not isinstance(data, pd.DataFrame):
            raise TypeError(
                "Parameter 'data' must be a pandas DataFrame.")
        if not isinstance(tier, pd.DataFrame):
            raise TypeError(
                "Parameter 'tier' must be a pandas DataFrame.")

        # Check if required columns exist in 'tier'
        required_tier_columns = ["Prefix/Course ID", "New Sector"]
        for col in required_tier_columns:
            if col not in tier.columns:
                raise KeyError(
                    f"Missing required column '{col}' in tier "
                    f"DataFrame.")

        # Check if required columns exist in 'data'
        required_data_columns = ["Sec Name", "Total FTE"]
        for col in required_data_columns:
            if col not in data.columns:
                raise KeyError(
                    f"Missing required column '{col}' in data "
                    f"DataFrame.")

        # create a dictionary to hold the course ID and their proposed
        # funding
        data["_Course Prefix"] = data["Sec Name"].str[:3]
        data.loc[:, "_Course Prefix"] =\
            data["_Course Prefix"].fillna("UNKNOWN")
        courseid_to_funding = {
            row["Prefix/Course ID"]: row["New Sector"]
            for _, row in tier.iterrows()
        }

        # Apply computed generated FTE to for all rows in original
        # DataFrame
        data["Generated FTE"] = data.apply(
            lambda row: compute_fte(row, courseid_to_funding, support),
            axis=1)
        data.drop(columns=["_Course Prefix"],
                  inplace=True, errors="ignore")

        return data

    except TypeError as e:
        print(f"TypeError in generate_fte: {e}")
    except KeyError as e:
        print(f"KeyError in generate_fte: {e}")

    return data.copy()

def compute_fte(row, courseid_to_funding, support=1926):
    """
    Computes the generate FTE for a single row in a dataframe
    :param row: pd.Series
        a row from the data DataFrame
    :param courseid_to_funding: dict
        a dictionary for the course prefixes and their funding levels
    :param support: int, optional
        a fixed amount for institutional and academic support(default
        is 1926)
    :return: float
        the computed generated FTE value for the row
    """

    try:
        # Ensure required columns are in DataFrame
        if "Sec Name" not in row:
            raise KeyError("Missing required column: 'Sec Name'")
        if "Total FTE" not in row:
            raise KeyError("Missing required column: 'Total FTE'")

        # Ensure 'Course Code' is a string and has at least 3 characters
        course_code = row["Sec Name"]
        if not isinstance(course_code, str) or len(course_code) < 3:
            raise ValueError(f"Invalid course code: {course_code}")

        # Extract prefix (first 3 chars)
        course_prefix = row["Sec Name"][:3]

        # Ensure 'Total FTE' is a number
        total_fte = row["Total FTE"]
        if (not isinstance(total_fte, (int, float))
                or pd.isna(total_fte)):
            raise ValueError(f"Invalid 'Total FTE' value: {total_fte}")

        # Get funding level and calculate generated FTE
        prop_fund = courseid_to_funding.get(course_prefix, 0)
        return (prop_fund + support) * total_fte

    except KeyError as e:
        print(f" KeyError in compute_fte: {e}")
    except ValueError as e:
        print(f" ValueError in compute_fte: {e}")
    except TypeError as e:
        print(f" TypeError in compute_fte: {e}")

    return 0  # Return 0 if an error occurs so program doesn't crash

def calculate_enrollment_percentage(count, capacity):
    """Calculates enrollment percentage based on course count and
    capacity

    Paramters
    ---------
    count: int
        Student enrolled in the course
    capacity: int
        Max number of students that can be enrolled
    """
    if isinstance(capacity, pd.Series):
        # Replace any 0 values in the Series with NaN to prevent
        # division errors
        capacity = capacity.replace(0, pd.NA)

    return ((count / capacity) * 100).round(1).astype(str) + "%"

def fte_faculty_submenu(faculty):
    """Prompt the user for input, validate, and return it.

    Parameters
    ----------
    faculty: list[str]
        List of valid faculty names.

    Returns
    -------
    str or None
        The faculty member name, or "To be Announced",
         or None if the user quits
    """
    keep_going = True
    while keep_going:

        # Prompt  user for faculty name to search for
        print(f"{'FTE by Faculty':-^2}\n")
        choice = input("Enter the first and/or last name of a faculty "
                       "member,\nTBA for classes with no announced "
                       "faculty,\n(or enter Q to quit) \n "
                       ">>> ").strip().title()
        if choice == 'Q':
            return None
        if choice == "Tba":
            return "To be Announced"

        # call function to search for faculty
        found_name = find_faculty(choice, faculty)

        # If multiple matches are found, prompt user to choose
        if isinstance(found_name, list) and len(found_name) > 1:
            found_name.append("None of these")  # Add a "None" option

            print_menu("Did you mean", found_name)
            name_choice = get_menu_choice(len(found_name))

            # User selects "None of these"
            if name_choice == len(found_name) - 1:
                found_name = None
            else:
                found_name = found_name[name_choice]

        # If exactly one match, return it
        elif isinstance(found_name, list) and len(found_name) == 1:
            found_name = found_name[0]

        # If no matches, notify user and loop again
        if not found_name:
            print(f"{choice} could not be found, "
                  f"please check spelling\n")
            continue  # Restart loop

        return found_name  # Return found faculty name


def find_faculty(search_for, to_search):
    """Searches faculty names for a match and returns None or the name
    in a list

    Parameters
    ----------
    search_for: str
        The name to search for.
    to_search: list[str]
        The names to search.

    Returns
    -------
    None | list[str]
        If not found returns None. Else, returns a list of all matches.
    """

    # Search for an exact faculty match
    name = [n for n in to_search if search_for == n]

    # If no exact match, attempt to match last names
    if not name:
        try:
            search_last = search_for.split()[1]  # Extract last name
            name = [n for n in to_search if n.split()[1] == search_last]
        except IndexError:
            # If user only provided one name, check against last names
            # in the list
            name = [n for n in to_search if search_for == n.split()[1]]

    # If still no match, compare first initials
    if not name:
        name = [n for n in to_search if search_for[0] == n[0]]

    # Return None if no match found
    return name if name else None

def get_course_codes(courses):
    """Cuts the section portion out of course codes.

    Parameters
    ----------
    courses: list[str]
        List of courses with sections.

    Returns
    -------
    set[str]
        Set of course codes without sections.
    """
    course_code_pattern = r"^([A-Z]{3}-\d{3}[A-Z]?)"
    course_codes = set()
    for code in courses:
        course_code = re.match(course_code_pattern, code)
        if course_code is not None:
            course_codes.add(course_code[1])

    return course_codes


def get_menu_choice(amount_options):
    """Prompts user for choice, validates, returns choice.

    print_menu is 0 based indexing on the back side but presented in the more
    readable format for the end user by adding 1 to the option number as it is
    printed to the screen. (Option 0 is presented as Option 1)

    Parameters
    ----------
    amount_options: int
        The amount of options presented to the end user.

    Returns
    -------
    int
        User input - 1
    """
    user_input = 0
    while user_input not in range(1, amount_options + 1):
        try:
            user_input = int(input("Enter a number between 1 and "
                                   f"{amount_options}: "))
        except ValueError:
            # Ignoring anything other than a number in the correct range
            ...
    # Need to remove the 1 added to the options when printed for
    # menus that aren't main
    return user_input - 1
    
def print_menu(header, options):
    """Print formatted menu

    Parameters
    ----------
    header: str
        menu header
    options: list[str]
        menu options
    """
    # Get the amount of digits in the length of  options (e.g. 15 = 2
    # digits).
    length_digits = len(str(len(options)))
    # Add 2 to account for the '. ' in the print loop.
    length_formatting = length_digits + 2
    # Get the length of the longest option for formatting.
    max_length = max(len(op) + length_formatting for op in options)
    if max_length < len(header):
        max_length = len(header) + length_digits

    print(f"{header:-^{max_length}}")
    for i, option in enumerate(options):
        print(f"{i + 1:>{length_digits}}. {option}")
        
def get_column_uniques(data, name):
    """Extracts unique values from a column within a DataFrame.

    Parameters
    ----------
    data: pd.DataFrame
        DataFrame to read from.
    name: str
        Name of the column to extract unique values.

    Returns
    -------
    list[str]
        List of unique values.
    """
    assert isinstance(data, pd.DataFrame)
    assert name is not None

    # Extract unique, non-null values
    unique_values = data[name].dropna().unique()
    # Explicit conversion to list[str] to prevent type errors
    return [str(x) for x in unique_values]
